#pragma config(Sensor, S1,     sensorIzquierdo, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorDerecho,  sensorEV3_Color)
#pragma config(Motor,  motorA,          motorIzquierdo, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motorDerecho,  tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int colorSensorIzquierdo(tSensors sIzquierdo){

	int colorIzquierdo = 0;
	int colorBlanco = 0;

	colorIzquierdo = getColorReflected(sIzquierdo);

	//PREGUNTA SI EL SENSOR IZQUIERDO ESTA EN EL BLANCO
	//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO
	//COMO VALOR SUPERIOR AL 60
	if(colorIzquierdo > 60)													{colorBlanco = 0;} 		//SE RETORNA 0 -> COLOR BLANCO;
	if(colorIzquierdo >= 10 && colorIzquierdo <= 60){colorBlanco = 2;}	  //SE RETORNA 2 -> COLOR POSIBLE VERDE;
	if(colorIzquierdo >= 2 && colorIzquierdo <= 10) {colorBlanco = 1;}		//SE RETORNA 1 -> COLOR NEGRO

	return colorBlanco;
}

int colorSensorDerecho(tSensors sDerecho){
	int colorDerecho = 0;
	int colorBlanco = 0;
	colorDerecho = getColorReflected(sDerecho);

	//PREGUNTA SI EL SENSOR DERECHO ESTA EN EL BLANCO
	//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO
	//COMO VALOR SUPERIOR AL 60
	if(colorDerecho > 60)                       {colorBlanco = 0;}        //SE RETORNA 0 -> COLOR BLANCO;
	if(colorDerecho >= 10 && colorDerecho <= 60){colorBlanco = 2;}        //SE RETORNA 2 -> COLOR POSIBLE VERDE
	if(colorDerecho >= 2 && colorDerecho <= 10) {colorBlanco = 1;}        //SE RETORNA 1 -> COLOR NEGRO;


	return colorBlanco;
}

int colorRGBSensorIzquierdo(tSensors sIzquierdo){
//VERDE HUE 170-180
//BLANCO HUE 200-215
//NEGRO HUE 215-235
//50% NEGRO 50% BLANCO HUE

	int colorSensor = 2;

	if(getColorReflected(sIzquierdo) < 60){
		int colorHUE = getColorHue(sIzquierdo);
		if(colorHUE <= 175){colorSensor = 3;}else{colorSensor = 1;}
	}else{colorSensor = 2;}

	return colorSensor;
	/*
	//VARIABLES DE CONTROL
	int redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sIzquierdo, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 1 && redChannel <= 5) && (greenChannel >= 7 && greenChannel <= 11) && (blueChannel >= 9 && blueChannel <= 14)){
	colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 30 && redChannel <= 38) && (greenChannel >= 62 && greenChannel <= 71) && (blueChannel >= 80 && blueChannel <= 88)){
	colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 16 && greenChannel <= 20) && (blueChannel >= 12 && blueChannel <= 17)){
	colorSensor = 3;//COLOR VERDE
	}
	*/

}

int colorRGBSensorDerecho(tSensors sDerecho){
//VERDE HUE 155-160
//BLANCO HUE 175-190
//NEGRO HUE	215-230
//50% NEGRO 50% BLANCO HUE 190-205
	int colorSensor = 2;

	if(getColorReflected(sDerecho) < 60){
		int colorHUE = getColorHue(sDerecho);
		if(colorHUE <= 115){colorSensor = 3;}else{colorSensor = 1;}
	}else{colorSensor = 2;}


	return colorSensor;
	/*
	//VARIABLES DE CONTROL
	int redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sDerecho, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 6 && greenChannel <= 10) && (blueChannel >= 6 && blueChannel <= 10)){
	colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 32 && redChannel <= 42) && (greenChannel >= 66 && greenChannel <= 74) && (blueChannel >= 64 && blueChannel <= 72)){
	colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 17 && greenChannel <= 21) && (blueChannel >= 9 && blueChannel <= 13)){
	colorSensor = 3;//COLOR VERDE
	}
	*/

}

task main(){
	//int sensorIzquierdoAverage = 70; VALOR REAL DE BLANCO SUPERIOR A 84
	//int sensorDerechoAverage = 70; VALOR REAL DE BLANCO SUPERIOR A 91
	int velocidadAvance = 20;
	int minMotorSpeed = -20;
	int colorIzq = 0;
	int colorDer = 0;
	int colorIzqRGB = 0;
	int colorDerRGB = 0;
	int controlLineaNegra = 0;
	int colorIzqReflected = 0;
	int colorDerReflected = 0;

	while (true)
	{
		colorIzq = colorSensorIzquierdo(sensorIzquierdo);
		colorDer = colorSensorDerecho(sensorDerecho);

 		colorIzqReflected = getColorReflected(sensorIzquierdo);
		colorDerReflected = getColorReflected(sensorDerecho);

		controlLineaNegra = round((((colorIzqReflected - colorDerReflected)/2)+6)*1.6/15);
		//controlLineaNegra = (((colorIzqReflected - colorDerReflected)/2)+6)*1.6/15;
		if(controlLineaNegra >= 4){controlLineaNegra = 3;}
		if(controlLineaNegra <= -4){controlLineaNegra = -3;}
		switch (controlLineaNegra)
		{
		case 3:
			setMotorSpeed(motorIzquierdo, velocidadAvance*2.7);
			setMotorSpeed(motorDerecho, minMotorSpeed*2.7);
			break;
		case 2:
			setMotorSpeed(motorIzquierdo, velocidadAvance*2.5);
			setMotorSpeed(motorDerecho, velocidadAvance/2);
			break;
		case 1:
			setMotorSpeed(motorIzquierdo, velocidadAvance*1.5);
			setMotorSpeed(motorDerecho, velocidadAvance/1.2);
			break;
		case 0:
			setMotorSpeed(motorIzquierdo, velocidadAvance);
			setMotorSpeed(motorDerecho, velocidadAvance);
			break;
		case -1:
			setMotorSpeed(motorIzquierdo, velocidadAvance/1.2);
			setMotorSpeed(motorDerecho, velocidadAvance*1.5);
			break;
		case -2:
			setMotorSpeed(motorIzquierdo, velocidadAvance/2);
			setMotorSpeed(motorDerecho, velocidadAvance*2.5);
			break;
		case -3:
			setMotorSpeed(motorIzquierdo, minMotorSpeed*2.7);
			setMotorSpeed(motorDerecho, velocidadAvance*2.7);
			break;
		}

		/*
		int giro = colorIzqReflected - colorDerReflected * 2;

		if(giro > 100){giro = 100;}
		if(giro < -100){giro = -100;}

		setMotorSyncTime(motorIzquierdo, motorDerecho, giro, 50, 40);
		sleep(50);


		if( colorIzq  == 0 && colorDer == 0)
		{
			setMotorSpeed(motorIzquierdo, velocidadAvance);
			setMotorSpeed(motorDerecho, velocidadAvance);
			displayCenteredBigTextLine(3,"AVANCE");
		}
		if( colorIzq  == 0 && colorDer != 0)
		{
			setMotorSpeed(motorIzquierdo, velocidadAvance);
			setMotorSpeed(motorDerecho, minMotorSpeed);
			displayCenteredBigTextLine(3,"DERECHA");
		}

		if (colorIzq  != 0 && colorDer == 0)
		{
			setMotorSpeed(motorIzquierdo,  minMotorSpeed);
			setMotorSpeed(motorDerecho, velocidadAvance);
			displayCenteredBigTextLine(3,"IZQUIERDA");
		}

		if (colorIzq  == 1 && colorDer == 1)
		{
			setMotorSpeed(motorIzquierdo, velocidadAvance);
			setMotorSpeed(motorDerecho, velocidadAvance);
			displayCenteredBigTextLine(3,"DOBLE NEGRO");
			sleep(1000);
		}
		*/

		if (colorIzq  == 2 ||  colorDer == 2)
		{

			if(colorIzq == 2){
				//playTone(1000, 3);
				//COMPROBACION DE VERDE
				displayCenteredBigTextLine(3,"POS VERDE IZQ");
				//AVANZA HACIA ADELANTE
				forward(0.05, rotations, velocidadAvance);
				//FRENA EL ROBOT
				setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
				playTone(1000, 3);
				sleep(3000);
				//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
				forward(0.05, rotations, velocidadAvance);
				sleep(500);
				colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
				displayCenteredBigTextLine(3,"colorIzq %d",colorIzqRGB);
				sleep(3000);
				//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
				if(colorIzqRGB == 3){
					//FRENO EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
					sleep(1000);
					//VERIFICA SI TAmotorIzquierdoIEN EL SENSOR DERECHO ESTA SOBRE EL VERDE
					//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
					if(colorDerRGB == 3){
						displayCenteredBigTextLine(3,"DOBLE VERDE");
						forward(0.3, rotations, velocidadAvance);
						turnLeft(2.5, rotations, velocidadAvance);
						forward(0.5, rotations, velocidadAvance);
						}else{
						//SINO SE GIRA HACIA LA IZQUIERDA
						playTone(1000, 3);
						displayCenteredBigTextLine(3,"VERDE IZQ");
						forward(0.3, rotations, velocidadAvance);
						turnLeft(1.3, rotations, velocidadAvance);
						forward(0.5, rotations, velocidadAvance);
						}
					}else{
					backward(0.05, rotations, velocidadAvance);
				}
			}

			if(colorDer == 2){
				//playTone(1000, 3);
				//COMPROBACION DE VERDE
				displayCenteredBigTextLine(3,"POS VERDE DER");
				//AVANZA HACIA ADELANTE
				forward(0.05, rotations, velocidadAvance);
				//FRENA EL ROBOT
				setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
				playTone(1000, 3);
				sleep(3000);
				//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
				forward(0.05, rotations, velocidadAvance);
				sleep(500);
				colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
				displayCenteredBigTextLine(3,"colorDer %d",colorDerRGB);
				sleep(3000);
				//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
				if(colorDerRGB == 3){
					//FRENO EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
					sleep(1000);
					//VERIFICA SI TAMBIEN EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
					if(colorIzqRGB == 3)
					{
						displayCenteredBigTextLine(3,"DOBLE VERDE");//2.6
					  forward(0.3, rotations, velocidadAvance);
						turnRight(2.5, rotations, velocidadAvance);
						forward(0.5, rotations, velocidadAvance);
					}
					else
					{
						//SINO SE GIRA HACIA LA DERECHA
						playTone(1000, 3);
						displayCenteredBigTextLine(3,"VERDE DER");
						forward(0.5, rotations, velocidadAvance);
						turnRight(1.3, rotations, velocidadAvance);
						forward(0.5, rotations, velocidadAvance);
					}
					}else{
					backward(0.05, rotations, velocidadAvance);
				}
			}/*
			while((colorIzq < sensorIzquierdoAverage) && (colorDer < sensorDerechoAverage)){
				setMotorSpeed(motorIzquierdo, 10);
				setMotorSpeed(motorDerecho, 20);
			}*/
		}

	}

}
