#pragma config(Sensor, S1,     sensorIzquierdo, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorDerecho,  sensorEV3_Color)
#pragma config(Motor,  motorA,          motorIzquierdo, tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          motorDerecho,  tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int colorSensorIzquierdo(tSensors sIzquierdo){

	int colorIzquierdo = 0;
	int colorBlanco = 0;

	colorIzquierdo = getColorReflected(sIzquierdo);

	//PREGUNTA SI EL SENSOR IZQUIERDO ESTA EN EL BLANCO
	if(colorIzquierdo > 30){ //SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorIzquierdo >= 3 && colorIzquierdo <= 3){ //5
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE;
		}else if(colorIzquierdo >= 4 && colorIzquierdo <= 6){ //7
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorSensorDerecho(tSensors sDerecho){

	int colorDerecho = 0;
	int colorBlanco = 0;

	colorDerecho = getColorReflected(sDerecho);

	//PREGUNTA SI EL SENSOR DERECHO ESTA EN EL BLANCO
	if(colorDerecho > 30){//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorDerecho >= 3 && colorDerecho <= 3){ //4
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE
		}else if(colorDerecho >= 4 && colorDerecho <= 10){ //6
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorRGBSensorIzquierdo(tSensors sIzquierdo){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sIzquierdo, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 4 && redChannel <= 9) && (greenChannel >= 16 && greenChannel <= 20) && (blueChannel >= 9 && blueChannel <= 14)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 48 && redChannel <= 53) && (greenChannel >= 18 && greenChannel <= 50) && (blueChannel >= 17 && blueChannel <= 19)){
		colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 7) && (greenChannel >= 6 && greenChannel <= 15) && (blueChannel >= 3 && blueChannel <= 10)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}

int colorRGBSensorDerecho(tSensors sDerecho){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sDerecho, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 6 && redChannel <= 11) && (greenChannel >= 15 && greenChannel <= 19) && (blueChannel >= 2 && blueChannel <= 6)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 57 && redChannel <= 62) && (greenChannel >= 57 && greenChannel <= 62) && (blueChannel >= 17 && blueChannel <= 18)){
		colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 7) && (greenChannel >= 6 && greenChannel <= 15) && (blueChannel >= 3 && blueChannel <= 10)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}


task main()
{
	int velocidadAvance = 30;//
	int minMotorSpeed = -30;//
	int sensorIzquierdoAverage = 30;//
	int sensorDerechoAverage = 30;//
	int colorIzq = 0;
	int colorDer = 0;
	int colorIzqRGB = 0;
	int colorDerRGB = 0;
	while (true)
	{
		if (getColorReflected(sensorIzquierdo) > sensorIzquierdoAverage)//
		{
			if (getColorReflected(sensorDerecho) > sensorDerechoAverage)//
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"AVANCE");
			}
			else
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, minMotorSpeed);
				displayCenteredBigTextLine(3,"DERECHA");
			}
		}
		else
		{
			if (getColorReflected(sensorDerecho)> sensorDerechoAverage)
			{
				setMotorSpeed(motorIzquierdo,  minMotorSpeed);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"IZQUIERDA");
			}
			else
			{
				colorIzq = colorSensorIzquierdo(sensorIzquierdo);
				colorDer = colorSensorDerecho(sensorDerecho);
				//Verdes
				if(colorIzq == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE IZQ");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
					sleep(75);
					//FRENA EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
					sleep(1200);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
					//
					if(colorIzqRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
						sleep(1200);
						//VERIFICA SI TAMBIEN EL SENSOR DERECHO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorDerRGB == 3)
						{
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(3000);
						}
						else
						{
							displayCenteredBigTextLine(3,"VERDE IZQ");
							/*
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(425);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, -velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							*/
							forward(0.5, rotations, velocidadAvance);
							turnLeft(0.7, rotations, velocidadAvance);
							forward(0.5, rotations, velocidadAvance);
						}
					}
				}

				if(colorDer == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE DER");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
					sleep(75);
					//FRENA EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
					sleep(1200);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					if(colorDerRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
						sleep(1200);
						//VERIFICA SI TAMBIEN EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorIzqRGB == 3)
						{
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(3000);
						}
						else
						{
							displayCenteredBigTextLine(3,"VERDE DER");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							setMotorSyncTime(motorIzquierdo, motorDerecho, -100, 0, velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
					}
				}

				while((getColorReflected(sensorIzquierdo) < sensorIzquierdoAverage)&&(getColorReflected(sensorDerecho) < sensorDerechoAverage)){
					setMotorSpeed(motorIzquierdo, 10);
					setMotorSpeed(motorDerecho,20);

				}
			}
		}
	}
}
