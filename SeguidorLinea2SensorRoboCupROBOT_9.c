#pragma config(Sensor, S1,     sensorIzquierdo, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorDerecho,  sensorEV3_Color)
#pragma config(Motor,  motorA,          motorIzquierdo, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorDerecho,  tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int colorSensorIzquierdo(tSensors sIzquierdo){

	int colorIzquierdo = 0;
	int colorBlanco = 0;

	colorIzquierdo = getColorReflected(sIzquierdo);

	//PREGUNTA SI EL SENSOR IZQUIERDO ESTA EN EL BLANCO
	if(colorIzquierdo > 84){ //SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorIzquierdo >= 47 && colorIzquierdo <= 84){ //11 - 16
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE;
		}else if(colorIzquierdo >= 2 && colorIzquierdo <= 47){ //9 -14
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorSensorDerecho(tSensors sDerecho){

	int colorDerecho = 0;
	int colorBlanco = 0;

	colorDerecho = getColorReflected(sDerecho);

	//PREGUNTA SI EL SENSOR DERECHO ESTA EN EL BLANCO
	if(colorDerecho > 91){//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorDerecho >= 44 && colorDerecho <= 91){ //11 - 16
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE
		}else if(colorDerecho >= 2 && colorDerecho <= 44){ //9 -15
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorRGBSensorIzquierdo(tSensors sIzquierdo){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sIzquierdo, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)
	/*
	if((redChannel >= 4 && redChannel <= 9) && (greenChannel >= 16 && greenChannel <= 20) && (blueChannel >= 9 && blueChannel <= 14)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 48 && redChannel <= 53) && (greenChannel >= 18 && greenChannel <= 50) && (blueChannel >= 17 && blueChannel <= 19)){
		colorSensor = 2;//COLOR BLANCO
	}
	*/
	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 16 && greenChannel <= 20) && (blueChannel >= 16 && blueChannel <= 20)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}

int colorRGBSensorDerecho(tSensors sDerecho){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sDerecho, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)
	/*
	if((redChannel >= 6 && redChannel <= 11) && (greenChannel >= 15 && greenChannel <= 19) && (blueChannel >= 2 && blueChannel <= 6)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 57 && redChannel <= 62) && (greenChannel >= 57 && greenChannel <= 62) && (blueChannel >= 17 && blueChannel <= 18)){
		colorSensor = 2;//COLOR BLANCO
	}
	*/
	if((redChannel >= 3 && redChannel <= 6) && (greenChannel >= 18 && greenChannel <= 22) && (blueChannel >= 10 && blueChannel <= 14)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}

task main()
{
	int velocidadAvance = 30;//
	int minMotorSpeed = -30;//
	int sensorIzquierdoAverage = 70;//VALOR REAL DE BLANCO SUPERIOR A 84
	int sensorDerechoAverage = 70;//VALOR REAL DE BLANCO SUPERIOR A 91
	int colorIzq = 0;
	int colorDer = 0;
	int colorIzqRGB = 0;
	int colorDerRGB = 0;
	while (true)
	{
		if (getColorReflected(sensorIzquierdo) > sensorIzquierdoAverage)//
		{
			if (getColorReflected(sensorDerecho) > sensorDerechoAverage)//
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"AVANCE");
			}
			else
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, minMotorSpeed);
				displayCenteredBigTextLine(3,"DERECHA");
			}
		}
		else
		{
			if (getColorReflected(sensorDerecho)> sensorDerechoAverage)
			{
				setMotorSpeed(motorIzquierdo,  minMotorSpeed);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"IZQUIERDA");
			}
			else
			{
				colorIzq = colorSensorIzquierdo(sensorIzquierdo);
				colorDer = colorSensorDerecho(sensorDerecho);
				//Verdes
				if(colorIzq == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE IZQ");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					forward(0.2,rotations, 10);
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
				  sleep(50);
					//FRENA EL ROBOT
					//setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 200,velocidadAvance);
					//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG

					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
					sleep(1800);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					if(colorIzqRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
						sleep(1800);
						//VERIFICA SI TAMBIEN EL SENSOR DERECHO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorDerRGB == 3 && colorIzqRGB == 3)
						{
							displayCenteredBigTextLine(3,"DOBLE VERDE");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(3600);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
						else
						{
							//SINO SE GIRA HACIA LA IZQUIERDA
							/*
							displayCenteredBigTextLine(3,"VERDE IZQ");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(425);
							setMotorSyncTime(motorIzquierdo, motorDerecho, -100, 0, velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							*/
							forward(0.5, rotations, velocidadAvance);
							turnLeft(0.7, rotations, velocidadAvance);
							forward(0.5, rotations, velocidadAvance);
						}
					}
				}

				if(colorDer == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE DER");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					forward(0.2,rotations, 10);
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
					sleep(50);
					//FRENA EL ROBOT
				//setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG

					colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
					sleep(1800);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					if(colorDerRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
						sleep(1800);
						//VERIFICA SI TAMBIEN EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorIzqRGB == 3 && colorDerRGB == 3)
						{
							displayCenteredBigTextLine(3,"DOBLE VERDE");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(3600);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
						else
						{
							//SINO SE GIRA HACIA LA DERECHA
							/*
							displayCenteredBigTextLine(3,"VERDE DER");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							*/
							forward(0.5, rotations, velocidadAvance);
							turnRight(0.7, rotations, velocidadAvance);
							forward(0.5, rotations, velocidadAvance);
						}
					}
				}

				while((getColorReflected(sensorIzquierdo) < sensorIzquierdoAverage)&&(getColorReflected(sensorDerecho) < sensorDerechoAverage)){
					setMotorSpeed(motorIzquierdo, 10);
					setMotorSpeed(motorDerecho, 20);
				}
			}
		}
	}
}
