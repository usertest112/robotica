#pragma config(Sensor, S1,     sensorIzquierdo, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorDerecho,  sensorEV3_Color)
#pragma config(Motor,  motorA,          motorIzquierdo, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          motorDerecho,  tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int colorSensorIzquierdo(tSensors sIzquierdo){

	int colorIzquierdo = 0;
	int colorBlanco = 0;

	colorIzquierdo = getColorReflected(sIzquierdo);

	//PREGUNTA SI EL SENSOR IZQUIERDO ESTA EN EL BLANCO
	if(colorIzquierdo > 90){ //SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorIzquierdo >= 23 && colorIzquierdo <= 32){
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE;
		}else if(colorIzquierdo >= 2 && colorIzquierdo <= 22){
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorSensorDerecho(tSensors sDerecho){

	int colorDerecho = 0;
	int colorBlanco = 0;

	colorDerecho = getColorReflected(sDerecho);

	//PREGUNTA SI EL SENSOR DERECHO ESTA EN EL BLANCO
	if(colorDerecho > 90){//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO COMO VALOR SUPERIOR AL 30
		colorBlanco = 1;//SE RETORNA 1 -> COLOR BLANCO;
		}else if(colorDerecho >= 46 && colorDerecho <= 70){
		colorBlanco = 2;//SE RETORNA 2 -> COLOR POSIBLE VERDE
		}else if(colorDerecho >= 2 && colorDerecho <= 45){
		colorBlanco = 0;//SE RETORNA 0 -> COLOR NEGRO;
	}
	return colorBlanco;
}

int colorRGBSensorIzquierdo(tSensors sIzquierdo){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sIzquierdo, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 1 && redChannel <= 5) && (greenChannel >= 7 && greenChannel <= 11) && (blueChannel >= 9 && blueChannel <= 14)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 32 && redChannel <= 36) && (greenChannel >= 65 && greenChannel <= 69) && (blueChannel >= 82 && blueChannel <= 86)){
		colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 16 && greenChannel <= 20) && (blueChannel >= 12 && blueChannel <= 17)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}

int colorRGBSensorDerecho(tSensors sDerecho){

	//VARIABLES DE CONTROL
	int colorSensor,redChannel,greenChannel,blueChannel = 0;
	//FUNCION QUE GUARDA LOS VALORES RGB EN LAS VARIABLES redChannel - greenChannel - blueChannel
	getColorRGB(sDerecho, redChannel, greenChannel, blueChannel);

	//VERIFICA SI LAS VARIABLES TIENEN EL VALOR ESPECIFICADO EN EL RANGO
	//DE VALORES RGB ESPECIFICO PARA CADA COLOR (NEGRO, BLANCO, VERDE)

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 6 && greenChannel <= 10) && (blueChannel >= 6 && blueChannel <= 10)){
		colorSensor = 1;//COLOR NEGRO
	}

	if((redChannel >= 34 && redChannel <= 40) && (greenChannel >= 68 && greenChannel <= 72) && (blueChannel >= 66 && blueChannel <= 70)){
		colorSensor = 2;//COLOR BLANCO
	}

	if((redChannel >= 2 && redChannel <= 6) && (greenChannel >= 17 && greenChannel <= 21) && (blueChannel >= 9 && blueChannel <= 13)){
		colorSensor = 3;//COLOR VERDE
	}

	return colorSensor;

}

task main()
{
	int velocidadAvance = 20;//
	int minMotorSpeed = -20;//
	int sensorIzquierdoAverage = 70;//VALOR REAL DE BLANCO SUPERIOR A 84
	int sensorDerechoAverage = 70;//VALOR REAL DE BLANCO SUPERIOR A 91
	int colorIzq = 0;
	int colorDer = 0;
	int colorIzqRGB = 0;
	int colorDerRGB = 0;
	while (true)
	{
		if (getColorReflected(sensorIzquierdo) > sensorIzquierdoAverage)//
		{
			if (getColorReflected(sensorDerecho) > sensorDerechoAverage)//
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"AVANCE");
			}
			else
			{
				setMotorSpeed(motorIzquierdo, velocidadAvance);
				setMotorSpeed(motorDerecho, minMotorSpeed);
				displayCenteredBigTextLine(3,"DERECHA");
			}
		}
		else
		{
			if (getColorReflected(sensorDerecho)> sensorDerechoAverage)
			{
				setMotorSpeed(motorIzquierdo,  minMotorSpeed);
				setMotorSpeed(motorDerecho, velocidadAvance);
				displayCenteredBigTextLine(3,"IZQUIERDA");
			}
			else
			{
				colorIzq = colorSensorIzquierdo(sensorIzquierdo);
				colorDer = colorSensorDerecho(sensorDerecho);
				//Verdes
				if(colorIzq == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE IZQ");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
					sleep(10);
					//FRENA EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
					sleep(1800);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					if(colorIzqRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
						sleep(1800);
						//VERIFICA SI TAMBIEN EL SENSOR DERECHO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorDerRGB == 3 && colorIzqRGB == 3){
							displayCenteredBigTextLine(3,"DOBLE VERDE");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(4000);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}else{
							//SINO SE GIRA HACIA LA IZQUIERDA
							playTone(1000, 3);
							displayCenteredBigTextLine(3,"VERDE IZQ");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							setMotorSyncTime(motorIzquierdo, motorDerecho, -100, 0, velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
					}
				}

				if(colorDer == 2){
					//playTone(1000, 3);
					//COMPROBACION DE VERDE
					displayCenteredBigTextLine(3,"POS VERDE DER");
					//AVANZA HACIA ADELANTE DURANTE 0,050s
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
					sleep(10);
					//FRENA EL ROBOT
					setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
					//GUARDA EL RGB EN LA VARIABLE colorDerRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
					colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
					sleep(1800);
					//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					if(colorDerRGB == 3){
						//FRENO EL ROBOT
						setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
						//GUARDA EL RGB EN LA VARIABLE colorIzqRGB ESPERANDO 1,8s PARA TOMAR BIEN LA GAMA RBG
						colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);
						sleep(1800);
						//VERIFICA SI TAMBIEN EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
						//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
						if(colorIzqRGB == 3 && colorDerRGB == 3)
						{
							displayCenteredBigTextLine(3,"DOBLE VERDE");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(4000);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
						else
						{
							//SINO SE GIRA HACIA LA DERECHA
							playTone(1000, 3);
							displayCenteredBigTextLine(3,"VERDE DER");
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, velocidadAvance);
							sleep(1700);
							setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, velocidadAvance);
							sleep(500);
						}
					}
				}

				while((getColorReflected(sensorIzquierdo) < sensorIzquierdoAverage) && (getColorReflected(sensorDerecho) < sensorDerechoAverage)){
					setMotorSpeed(motorIzquierdo, 10);
					setMotorSpeed(motorDerecho, 20);
				}
			}
		}
	}
}
