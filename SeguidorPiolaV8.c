#pragma config(Sensor, S1,     sensorIzquierdo, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorDerecho,  sensorEV3_Color)
#pragma config(Sensor, S3,     sensorCentro,   sensorEV3_Color)
#pragma config(Sensor, S4,     sensorUltrasonic, sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          motorIzquierdo, tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motorDerecho,  tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          motorRescate,  tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int colorSensorIzquierdo(tSensors sIzquierdo){

	int colorIzquierdo = 0;
	int colorBlanco = 0;

	colorIzquierdo = getColorReflected(sIzquierdo);

	//PREGUNTA SI EL SENSOR IZQUIERDO ESTA EN EL BLANCO
	//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO
	//COMO VALOR SUPERIOR AL 27
	if(colorIzquierdo > 12)												{colorBlanco = 0;} 		//SE RETORNA 0 -> COLOR BLANCO;
	if(colorIzquierdo >= 4 && colorIzquierdo <= 11){colorBlanco = 2;}	  //SE RETORNA 2 -> COLOR POSIBLE VERDE;
	if(colorIzquierdo >= 1 && colorIzquierdo <= 3){colorBlanco = 1;}		//SE RETORNA 1 -> COLOR NEGRO

	return colorBlanco;
}

int colorSensorDerecho(tSensors sDerecho){

	int colorDerecho = 0;
	int colorBlanco = 0;


	colorDerecho = getColorReflected(sDerecho);

	//PREGUNTA SI EL SENSOR DERECHO ESTA EN EL BLANCO
	//SE TOMA COMO VALOR DE REFERENCIA EN BLANCO
	//COMO VALOR SUPERIOR AL 45
	if(colorDerecho > 12)                      {colorBlanco = 0;}        //SE RETORNA 0 -> COLOR BLANCO;
	if(colorDerecho >= 7 && colorDerecho <= 11){colorBlanco = 2;}        //SE RETORNA 2 -> COLOR POSIBLE VERDE
	if(colorDerecho >= 2 && colorDerecho <= 6)  {colorBlanco = 1;}        //SE RETORNA 1 -> COLOR NEGRO;


	return colorBlanco;
}

int colorRGBSensorIzquierdo(tSensors sIzquierdo){

	int colorSensor = 2;
	int colorHUE = 0;
	int tiempoLectura = 1000;

	if(getColorReflected(sIzquierdo) < 20){
		while(tiempoLectura > -1){colorHUE = getColorHue(sIzquierdo); tiempoLectura--;}
		if(colorHUE >= 105 && colorHUE <= 115){colorSensor = 3;}else{colorSensor = 1;}
	}else{colorSensor = 2;}

	return colorSensor;
}

int colorRGBSensorDerecho(tSensors sDerecho){

	int colorSensor = 2;
	int colorHUE = 0;
	int tiempoLectura = 1000;

	if(getColorReflected(sDerecho) < 27 ){
		while(tiempoLectura > -1){colorHUE = getColorHue(sDerecho); tiempoLectura--;}
		if(colorHUE >= 150 && colorHUE <= 175){colorSensor = 3;}else{colorSensor = 1;}
	}else{colorSensor = 2;}


	return colorSensor;

}

task main(){

	int velocidadAvance = 25;
	int colorIzq = 0;
	int colorDer = 0;
	int colorIzqRGB = 0;
	int colorDerRGB = 0;
	int controlLineaNegra = 0;
	int colorIzqReflected = 0;
	int colorDerReflected = 0;
	int colorCenReflected = 0;

	while(true){

		colorIzqReflected = getColorReflected(sensorIzquierdo);
		colorDerReflected = getColorReflected(sensorDerecho);
		colorCenReflected = getColorReflected(sensorCentro);

		while(colorIzqReflected < 60 && colorDerReflected < 90){
		seguidorLinea:
			colorIzqReflected = getColorReflected(sensorIzquierdo);
			colorDerReflected = getColorReflected(sensorDerecho);
			colorCenReflected = getColorReflected(sensorCentro);

/*		if(colorIzqReflected <= 10 && colorCenReflected <= 25){
				setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
				forward(1.5, rotations, velocidadAvance);
			}

			if(colorDerReflected <= 10 && colorCenReflected <= 25){
				setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 0);
				forward(1.5, rotations, velocidadAvance);
			}
*/
			controlLineaNegra = round((((colorIzqReflected - colorDerReflected)/2)+8)*1.6/15);

			if(controlLineaNegra >= 4){controlLineaNegra = 3;}
			if(controlLineaNegra <= -4){controlLineaNegra = -3;}

			switch (controlLineaNegra){
			case 3:
				setMotorSpeed(motorIzquierdo, 99);
				setMotorSpeed(motorDerecho, -99);
				break;
			case 2:
				setMotorSpeed(motorIzquierdo, 66);
				setMotorSpeed(motorDerecho, -66);
				break;
			case 1:
				setMotorSpeed(motorIzquierdo, 33);
				setMotorSpeed(motorDerecho, -33);
				break;
			case 0:
				setMotorSpeed(motorIzquierdo, 40);
				setMotorSpeed(motorDerecho, 40);
				break;
			case -1:
				setMotorSpeed(motorIzquierdo, -33);
				setMotorSpeed(motorDerecho, 33);
				break;
			case -2:
				setMotorSpeed(motorIzquierdo, -66);
				setMotorSpeed(motorDerecho, 66);
				break;
			case -3:
				setMotorSpeed(motorIzquierdo, -99);
				setMotorSpeed(motorDerecho, 99);
				break;
			}

			colorIzq = colorSensorIzquierdo(sensorIzquierdo);
			colorDer = colorSensorDerecho(sensorDerecho);

			if (colorIzq  == 2 ||  colorDer == 2){

				if(colorIzq == 2){//COMPROBACION DE VERDE

					displayCenteredBigTextLine(3,"POS VERDE IZQ");
					stopMultipleMotors(motorDerecho, motorIzquierdo);//FRENA EL ROBOT
					forward(0.05, rotations, velocidadAvance); //AVANZA
					colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);//COMPRUEBA SI EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
					displayCenteredBigTextLine(3,"colorIzq %d",colorIzqRGB);

					if(colorIzqRGB == 3){
						stopMultipleMotors(motorDerecho, motorIzquierdo);//FRENO EL ROBOT
						colorDerRGB = colorRGBSensorDerecho(sensorDerecho);//GUARDA EL RGB EN LA VARIABLE colorDerRGB
						sleep(500);
						if(colorIzqRGB == 1 || colorIzqRGB == 2){
							if(colorIzqRGB == 1 && colorDerRGB == 1){
								setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}
							if(colorIzqRGB == 1){
								setMotorSyncTime(motorIzquierdo, motorDerecho, -100, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}else{
								setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}
						}else{
							if(colorDerRGB == 3){//VERIFICA SI TAMBIEN EL SENSOR DERECHO ESTA SOBRE EL VERDE
								displayCenteredBigTextLine(3,"DOBLE VERDE");//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
								forward(0.3, rotations, 25);
								turnLeft(2.5, rotations, 25);
								forward(0.5, rotations, 25);
							}else{
								//SINO SE GIRA HACIA LA IZQUIERDA
								displayCenteredBigTextLine(3,"VERDE IZQ");
								forward(0.35, rotations, 25);
								turnLeft(1.1, rotations, 25);
								forward(0.15, rotations, 25);
							}
						}
						}else{
						backward(0.05, rotations, 25);
					}
				}

				if(colorDer == 2){ //COMPROBACION DE VERDE

					displayCenteredBigTextLine(3,"POS VERDE DER");
					stopMultipleMotors(motorDerecho, motorIzquierdo);  //FRENA EL ROBOT
					forward(0.05, rotations, velocidadAvance); //AVANZA
					colorDerRGB = colorRGBSensorDerecho(sensorDerecho);
					displayCenteredBigTextLine(3,"colorDer %d",colorDerRGB);
					//COMPRUEBA SI EL SENSOR DERECHO ESTA SOBRE EL VERDE

					if(colorDerRGB == 3){
						stopMultipleMotors(motorDerecho, motorIzquierdo);//FRENO EL ROBOT
						colorIzqRGB = colorRGBSensorIzquierdo(sensorIzquierdo);	//GUARDA EL RGB EN LA VARIABLE colorIzqRGB.
						sleep(500);
						if(colorDerRGB == 1 || colorDerRGB == 2){
							if(colorDerRGB == 1 && colorIzqRGB == 1){
								setMotorSyncTime(motorIzquierdo, motorDerecho, 0, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}
							if(colorDerRGB == 1){
								setMotorSyncTime(motorIzquierdo, motorDerecho, 100, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}else{
								setMotorSyncTime(motorIzquierdo, motorDerecho, -100, 0, 100);
								sleep(275);
								goto seguidorLinea;
							}
						}else{
							if(colorIzqRGB == 3){	//VERIFICA SI TAMBIEN EL SENSOR IZQUIERDO ESTA SOBRE EL VERDE
								displayCenteredBigTextLine(3,"DOBLE VERDE");//SI LA CONDICION ES VERDADERA ENTONCES ES DOBLE VERDE
								forward(0.3, rotations, 25);
								turnRight(2.5, rotations, 25);
								forward(0.5, rotations, 25);
							}else{
								//SINO SE GIRA HACIA LA DERECHA
								displayCenteredBigTextLine(3,"VERDE DER");
								forward(0.35, rotations, 25);
								turnRight(1, rotations, 25);
								forward(0.15, rotations, 25);
							}
						}
						}else{
						backward(0.05, rotations, 25);
					}
				}

			}//endIf
		}//endWhileCondition

	}//endWhileInfinity

}
